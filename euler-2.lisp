;Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

;1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

;By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.


;; This function should be tail-recursive right?
(defun fib-helper (a b n)
  (let ((c (+ a b)))
    (if (>= 0 (1- n))
	c
	(fib-helper b c (1- n)))))


; If I time this one is actually faster though. hunh. Only by a bit. I should try for larger values when I'm not running off of battery juice...
(defun fib-helper-slow (a b n)
  (let ((c (+ a b)))
    (if (>= (1- n) 0)
	(fib-helper b c (1- n))
	c)))


(defun fib (n)
  (fib-helper 0 1 n))


(defun fib-list-helper (list n limit)
  (let ((calculated-fib (fib n)))
    (if (< calculated-fib limit)
	(list-constructor (cons calculated-fib list) (1+ n))
	list)))

(defun fib-list-under-four-million ()
  (fib-list-helper nil 4000000))

(defun list-no-odds (list)
  (remove-if-not #'(lambda (x)
		     (evenp x))
		 list))

; This we call recursively adding the result of the previous call if our value is
; less than 4000000
(defun euler-2-helper (list fib-n)
  

;; So how are we going to approach this? Lets recursively make a list of all the fib values from 0 to 		       
(defun euler-2 ()
  (euler-2-helper '() ))